= Deploy Gramola With GitOps
include::_attributes.adoc[]

As we have already explained in the introduction the main objective of this guide is introduce you to *GitOps* taking *Gramola* as the example application we want to deploy.

In this chapter you're going to deploy Gramola using *ArgoCD* hence you're not going to create the descriptors yourself. Instead *ArgoCD* will *go* to the *source of truth* (_git url, path and revision_), and  *apply* those descriptors in the defined *destination* (_cluster and namespace_).

[#concepts]
== Concepts

As you can imagine there should be an object *ArgoCD* can rely on to store both *spec->source* and *spec->destination*, this object is the `Application` object. This is an example of an `Application` object:

[source,yaml, subs="+macros,+attributes"]
----
apiVersion: argoproj.io/v1alpha1
kind: Application
metadata:
  name: events-app-dev-user1 <1>
  namespace: openshift-gitops
  finalizers:
    - resources-finalizer.argocd.argoproj.io
  labels:
    app.kubernetes.io/instance: gramola-root-app-dev-user1
spec:
  project: gramola-project-dev
  source: <2>
    repoURL: https://{gitea-host}/user1/gramola.git
    targetRevision: HEAD
    path: events-deployment/overlays/dev
    plugin:
      name: kustomized-helm <4>
      env:
        - name: DESTINATION_NAME
          value: in-cluster
        - name: BASE_REPO_URL
          value: https://{gitea-host}/user1/gramola
        - name: NAMESPACE_SUFFIX
          value: '-user1'
  destination: <3>
    name: in-cluster
    namespace: gramola-dev-user1
  syncPolicy:
    automated: {}
----
<1> Name of the application
<2> Source of truth, git url, path, revision and plugin to use
<3> Defines the destination of the descriptors found in the source of truth
<4> Plugin used to get the descriptors from the source git repository

The broad concept of `Application` usually implies several components and/or microservices if you will. This means that in general when we talk about applications in real life they are more applications of applications or root applications. Don't worry this is covered in *ArgoCD* with the concept `Application` the only thing you do is point the root application to a source where there are other `Applications` that could potentially point to other `Applications`, etc.

For instance in Gramola we will need to define one root application per environment, one for `dev` and one another for `test`. In this specific case, we would need to define a root app as the mother of a couple of root apps, one for `dev` and one for `test`, right? Something like this.

image::gramola-root-app.png[Gramola Root App]

For these situations where there are little differences between sibling applications ArgoCD has another and very powerful object the `ApplicationSet`. An `ApplicationSet` is basically an `Application` template that can be fed with values generated by a generator.

We're going to learn about `ApplicationSets` in the next chapter.

[#deploying-gramola]
== Deploying Gramola

Well, it's time to use ArgoCD to deploy Gramola, as we have advanced we're going to define an `ApplicationSet` that uses a *generator* to create an `Application` object for each of the environments we need: `dev` and `test` in this case.

You have to run the next command that created the `ApplicationSet` object that deploys Gramola in `dev` and `test` by using a list generator{empty}footnote:[https://argo-cd.readthedocs.io/en/stable/operator-manual/applicationset/Generators/] and deploys the descriptors obtained by using the helm{empty}footnote:[https://argoproj.github.io/argo-cd/user-guide/helm/] plugin.

[NOTE]
====
You can use the value of any of the properties defined in the elements listed in the generator (spec->generators->list->elements), in this case `env` and `desc`. In order to use a value in the spec->template area use double curly braces as you would in helm `{{ env }}`.
====

[.console-input]
[source,bash, subs="+macros,+attributes"]
----
export USERNAME="{username}"
cat <<EOF | oc apply -n {root-apps-namespace} -f -
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: gramola-$\{USERNAME}
  namespace: openshift-gitops
  labels:
    argocd-root-app: "true"
    username: $\{USERNAME}
spec:
  generators:
  - list:
      elements:
      - env: dev
        desc: "Gramola Dev"
      - env: test
        desc: "Gramola Test"
  template:
    metadata:
      name: gramola-root-app-{{ env }}-$\{USERNAME}
      namespace: openshift-gitops
      labels:
        argocd-root-app: "true"
        username: $\{USERNAME}
      finalizers:
      - resources-finalizer.argocd.argoproj.io
    spec:
      destination:
        namespace: openshift-gitops
        name: in-cluster
      project: default
      syncPolicy:
        automated:
          selfHeal: true
      source:
        helm:
          parameters:
            - name: baseRepoUrl
              value: https://{gitea-host}/{username}/gramola
            - name: namespaceSuffix
              value: "-$\{USERNAME}"
            - name: username
              value: "{username}"
        path: apps/{{ env }}
        repoURL: https://{gitea-host}/{username}/gramola.git
        targetRevision: HEAD
EOF
----

You should see something like.

[.console-output]
[source,bash, subs="+macros,+attributes"]
----
application.argoproj.io/gramola-{username} created
----

Let's go to ArgoCD console and see how it's going on. Please copy the next link and open it in a new tab.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{argocd-server}/applications
----

This is the expected result once all images have been pulled and the services are deployed completely.

image::argocd-gramola-deployed.png[ArgoCD Gramola Deployed]

You can also have a look to the `dev` environment using the OpenShift console. Please, copy the next link and paste it in a new tab.

[.console-input]
[source,bash, subs="+attributes"]
----
https://console-openshift-console.apps.%BASE_SUBDOMAIN%/topology/ns/gramola-dev-{username}?view=graph
----

To change to the `test` environment, just select `gramola-test-{username}` as in the next picture.

image::openshift-console-project-selection.png[Project Selection]

Let's test gramola, in both environments by clicking on the URL icon of `gateway` as in the next picture.

image::gramola-gateway-topology-url.png[Gateway URL]

You should see this simple user interface.

[NOTE]
====
Please take into account this:

- The first green area shows the status of the `Gateway` and also the service name as stated in `src/main/resources/application.properties`
- The second green area shows the status of the backend service `Events` and also the service name as stated in `src/main/resources/application.properties`
- This interface refreshes itself every 2 seconds, so if you change the name of the service or there is a problem you should be able to see it here
====

image::gramola-gateway-ui-1.png[Gateway UI]

[#deploying-gramola-additional]
== Deploying Gramola++

If an additional cluster has been set up in chapter xref:04-prepare-argocd.adoc#register-additional-clusters[Register Additional Clusters] then you can create another `ApplicationSet` where the destination cluster is the one you defined previously instead of the default (`in-cluster`) cluster.

[.console-input]
[source,bash, subs="+macros,+attributes"]
----
export USERNAME="{username}"
cat <<EOF | oc apply -n {root-apps-namespace} -f -
apiVersion: argoproj.io/v1alpha1
kind: ApplicationSet
metadata:
  name: gramola-cloud-$\{USERNAME}
  namespace: openshift-gitops
  labels:
    argocd-root-app: "true"
    username: $\{USERNAME}
spec:
  generators:
  - list:
      elements:
      - env: test-cloud
        desc: "Gramola Test"
  template:
    metadata:
      name: gramola-root-app-{{ env }}-$\{USERNAME}
      namespace: openshift-gitops
      labels:
        argocd-root-app: "true"
        username: $\{USERNAME}
      finalizers:
      - resources-finalizer.argocd.argoproj.io
    spec:
      destination:
        namespace: openshift-gitops
        name: in-cluster
      project: default
      syncPolicy:
        automated:
          selfHeal: true
      source:
        helm:
          parameters:
            - name: baseRepoUrl
              value: https://{gitea-host}/{username}/gramola
            - name: namespaceSuffix
              value: "-$\{USERNAME}"
            - name: username
              value: "{username}"
        path: apps/{{ env }}
        repoURL: https://{gitea-host}/{username}/gramola.git
        targetRevision: HEAD
EOF
----

Similarly if you created the root app for the additional cluster you should see...

[.console-output]
[source,bash, subs="+macros,+attributes"]
----
application.argoproj.io/gramola-cloud-user1 created
----

Please go to ArgoCD console and see how it's going on. Please copy the next link and open it in a new tab.

[.console-input]
[source,bash, subs="+attributes"]
----
https://{argocd-server}/applications?cluster=aws-managed1
----

This is the expected result once all images have been pulled and the services are deployed completely.

image::argocd-gramola-cloud-deployed.png[ArgoCD Gramola Deployed]

You can also have a look to the `test` environment in the additional cluster using the OpenShift console. Please, copy the next link and paste it in a new tab, please use these credentials:

- *USERNAME:* {username}
- *PASSWORD:* {password}

[.console-input]
[source,bash, subs="+attributes"]
----
https://console-openshift-console.apps.%ADDITIONAL_BASE_SUBDOMAIN%/topology/ns/gramola-test-{username}?view=graph
----

[#argocd-ui-filtering]
== ArgoCD UI Filtering

ArgoCD has a lots of options to filter objects, namely:

- Favorites
- Sync Status
- Health Status
- Labels
- Projects
- Clusters
- Namespaces

image::argocd-ui-filtering-1.png[ArgoCD Filtering Area]

Feel free to play with all of them and have a taste of how they work.

Once you're done please try this one, `Labels` and choose `username={username}` as in the next picture, if you're running this guide along with other users in the same cluster, you'll find it very useful to see only your objects.

image::argocd-ui-filtering-2.png[ArgoCD Filtering Area]
